#### sort
  -t：设定间隔符
  -k: 指定列数
  -n: 数值排序

    公司名称 人数 工资
    google 110 5000
    baidu 100 5000
    guge 50 3000
    sohu 100 4500

- 按照公司名称字母顺序排序

  ```sort -t " " -k 1 demo1.txt ```

      baidu 100 5000
      google 110 5000
      guge 50 3000
      sohu 100 450
- 按照公司人数排序

  ``` sort -t " " -rk 2 demo1.txt ```

      sohu 100 4500
      baidu 100 5000
      google 110 5000
      guge 50 3000
- 按照公司人数排序 ，人数相同的按照员工平均工资升序排序

  ```sort -n -t " " -k 2 -k 3 demo1.txt ```

      guge 50 3000
      sohu 100 4500
      baidu 100 5000
      google 110 5000
- 按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序

  ```sort -n -t " " -k 3r -k 2 demo1.txt```

      baidu 100 5000
      google 110 5000
      sohu 100 4500
      guge 50 3000
- -k选项的具体语法格式
    要继续往下深入的话，就不得不来点理论知识。你需要了解-k选项的语法格式，如下：

    ```[ FStart [ .CStart ] ] [ Modifier ] [ , [ FEnd [ .CEnd ] ][ Modifier ] ]```

    这个语法格式可以被其中的逗号（“，”）分为两大部分，Start部分和End部分。
    先给你灌输一个思想，那就是“如果不设定End部分，那么就认为End被设定为行尾”。这个概念很重要的，但往往你不会重视它。
    Start部分也由三部分组成，其中的Modifier部分就是我们之前说过的类似n和r的选项部分。我们重点说说Start部分的FStart和C.Start。
    C.Start也是可以省略的，省略的话就表示从本域的开头部分开始。之前例子中的-k 2和-k 3就是省略了C.Start的例子喽。
    FStart.CStart，其中FStart就是表示使用的域，而CStart则表示在FStart域中从第几个字符开始算“排序首字符”。
    同理，在End部分中，你可以设定FEnd.CEnd，如果你省略.CEnd，则表示结尾到“域尾”，即本域的最后一个字符。或者，如果你将CEnd设定为0(零)，也是表示结尾到“域尾”。
   - 从公司英文名称的第二个字母开始进行排序

     ```sort -t " " -k 1.2r demo1.txt ```

         baidu 100 5000
         sohu 100 4500
         google 110 5000
         guge 50 3000
   - 只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序

     ```sort -t " " -k 1.2,1.2 -k 3nr demo1.txt```

         baidu 100 5000
         google 110 5000
         sohu 100 4500
         guge 50 3000
- 关于-k和-u联合使用的例子：

  ```sort -n -k 2 -u demo1.txt```

      guge 50 3000
      baidu 100 5000
      google 110 5000

  当设定以公司员工域进行数值排序，然后加-u后，sohu一行就被删除了！原来-u只识别用-k设定的域，发现相同，就将后续相同的行都删除。

  ```sort -n -k 2 -k 3 -u demo1.txt```

  这里设置了两层排序优先级的情况下，使用-u就没有删除任何行。原来-u是会权衡所有-k选项，将都相同的才会删除，只要其中有一级不同都不会轻易删除的:)（不信，你可以自己加一行sina 100 4500试试看）

  加上sina，sohu被删除了

      guge 50 3000
      sina 100 4500
      baidu 100 5000
      google 110 5000
- 最诡异的排序：

  ```$ sort -n -k 2.2,3.1 facebook.txt```

      guge 50 3000
      baidu 100 5000
      sohu 100 4500
      google 110 5000

  以第二个域的第二个字符开始到第三个域的第一个字符结束的部分进行排序。

  第一行，会提取0 3，第二行提取00 5，第三行提取00 4，第四行提取10 5。

  又因为sort认为0小于00小于000小于0000….

  因此0 3肯定是在第一个。10 5肯定是在最后一个。但为什么00 5却在00 4前面呢？（你可以自己做实验思考一下。）

  答案揭晓：原来“跨域的设定是个假象”，sort只会比较第二个域的第二个字符到第二个域的最后一个字符的部分，而不会把第三个域的开头字符纳入比较范围。当发现00和00相同时，sort就会自动比较第一个域去了。当然baidu在sohu前面了。用一个范例即可证实：

  ```$ sort -n -k 2.2,3.1 -k 1,1r facebook.txt```

      guge 50 3000
      sohu 100 4500
      baidu 100 5000
      google 110 5000

